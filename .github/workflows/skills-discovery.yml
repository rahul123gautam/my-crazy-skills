name: Skills Discovery with OpenCode Zen

on:
  schedule:
    - cron: "0 */8 * * *"
  workflow_dispatch:
    inputs:
      search_query:
        description: "Search query for skills repositories"
        required: false
        default: "topic:ai-skill OR topic:skill"
        type: string
  issues:
    types: [opened]

concurrency:
  group: skills-discovery-${{ github.event_name }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  parse-issue:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    outputs:
      repo_urls: ${{ steps.extract.outputs.repo_urls }}
      should_continue: ${{ steps.extract.outputs.should_continue }}
      permission_ok: ${{ steps.permission.outputs.permission_ok }}
      category_override: ${{ steps.extract.outputs.category_override }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check issue author permissions
        id: permission
        run: |
          set -euo pipefail
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          AUTHOR="${{ github.event.issue.user.login }}"

          PERM=$(gh api "repos/${{ github.repository }}/collaborators/${AUTHOR}/permission" --jq '.permission' 2>/dev/null || echo "none")

          case "$PERM" in
            admin|maintain|write)
              echo "permission_ok=true" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "permission_ok=false" >> $GITHUB_OUTPUT
              gh issue comment "$ISSUE_NUMBER" \
                --body "‚ö†Ô∏è This automation only accepts requests from users with **write** access (or higher). Please ask a maintainer to submit the request."
              gh issue close "$ISSUE_NUMBER"
              ;;
          esac
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create labels if they don't exist
        if: steps.permission.outputs.permission_ok == 'true'
        run: |
          # Create all labels needed by the workflow (ignore errors if they already exist)
          gh label create "automation-processing" --color "FBCA04" --description "Being processed by automation" 2>/dev/null || true
          gh label create "automation-complete" --color "0E8A16" --description "Automation completed successfully" 2>/dev/null || true
          gh label create "automation-failed" --color "D93F0B" --description "Automation failed" 2>/dev/null || true
          gh label create "pr-created" --color "1D76DB" --description "PR has been created" 2>/dev/null || true
          gh label create "automated" --color "0E8A16" --description "Automated by GitHub Actions" 2>/dev/null || true
          gh label create "skills-addition" --color "1D76DB" --description "Adding new skills" 2>/dev/null || true
          gh label create "opencode-integration" --color "5319E7" --description "Uses OpenCode AI categorization" 2>/dev/null || true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse issue for repo URLs
        id: extract
        if: steps.permission.outputs.permission_ok == 'true'
        run: |
          set -euo pipefail
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          ISSUE_BODY=$(cat << 'EOF'
          ${{ github.event.issue.body }}
          EOF
          )
          ISSUE_TITLE="${{ github.event.issue.title }}"
          ISSUE_TEXT="${ISSUE_TITLE}\n${ISSUE_BODY}"
          CATEGORY_OVERRIDE=""

          echo "Debug - Issue Title: $ISSUE_TITLE"
          echo "Debug - Issue Body: $ISSUE_BODY"

          TITLE_MATCH="false"
          if [[ "$ISSUE_TITLE" =~ (\[ADD\ SKILL\]|Add\ Skill|add\ skill|Skill\ Request|skill\ request) ]]; then
            TITLE_MATCH="true"
          fi

          # Optional category override (applies to all repos in this issue)
          CATEGORY_OVERRIDE=$(echo "$ISSUE_TEXT" | grep -iE 'category:' | head -n1 | sed -E 's/.*category:\s*//I' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]' || true)
          case "$CATEGORY_OVERRIDE" in
            learning|frontend|creative|research|tooling|workflows|platforms|publishing)
              echo "Detected category override: $CATEGORY_OVERRIDE"
              ;;
            "")
              ;;
            *)
              echo "Unknown category override: $CATEGORY_OVERRIDE (ignored)"
              CATEGORY_OVERRIDE=""
              ;;
          esac

          # Extract GitHub repo URLs
          echo -e "$ISSUE_TEXT" | grep -oE 'https://github\.com/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+' > /tmp/repos_urls.txt || true

          # Extract owner/repo shorthand and normalize into URLs
          echo -e "$ISSUE_TEXT" | grep -oE '\b[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+\b' | grep -vE '^https?://' > /tmp/repos_slugs.txt || true
          if [[ -s /tmp/repos_slugs.txt ]]; then
            awk '{print "https://github.com/" $0}' /tmp/repos_slugs.txt >> /tmp/repos_urls.txt
          fi

          if [[ -s /tmp/repos_urls.txt ]]; then
            sed -E 's#\\.git$##; s#/$##' /tmp/repos_urls.txt | sort -u > /tmp/repos.txt
          else
            : > /tmp/repos.txt
          fi

          REPO_COUNT=$(wc -l < /tmp/repos.txt | tr -d ' ')

          echo "Debug - Found $REPO_COUNT repository URLs"

          if [[ -f /tmp/repos.txt ]]; then
            echo "Debug - Repository URLs found:"
            cat /tmp/repos.txt
          fi

          if [[ "$TITLE_MATCH" != "true" && "$REPO_COUNT" -eq 0 ]]; then
            echo "should_continue=false" >> $GITHUB_OUTPUT
            echo "Issue title doesn't match pattern and no repo URLs found, skipping"
            exit 0
          fi

          if [[ "$REPO_COUNT" -eq 0 ]]; then
            echo "should_continue=false" >> $GITHUB_OUTPUT
            echo "No valid GitHub repository URLs found in issue"
            gh issue comment "$ISSUE_NUMBER" \
              --body "‚ö†Ô∏è No valid GitHub repository URLs found in this issue. Please format like:
              \`\`\`
              https://github.com/owner/repo
              owner/repo
              \`\`\`
              
              Your issue body was:
              \`\`\`
              $ISSUE_BODY
              \`\`\`" || echo "Failed to comment on issue"
            exit 0
          fi

          REPO_JSON=$(cat /tmp/repos.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "repo_urls=$REPO_JSON" >> $GITHUB_OUTPUT
          echo "category_override=$CATEGORY_OVERRIDE" >> $GITHUB_OUTPUT
          echo "should_continue=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Found $REPO_COUNT repository URLs"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Add processing label
        if: steps.permission.outputs.permission_ok == 'true' && steps.extract.outputs.should_continue == 'true'
        run: |
          gh issue edit "${{ github.event.issue.number }}" \
            --add-label "automation-processing"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  discover-trending:
    if: github.event_name != 'issues'
    runs-on: ubuntu-latest
    outputs:
      trending_repos: ${{ steps.search.outputs.trending_repos }}
    steps:
      - name: Search for trending skills repositories
        id: search
        run: |
          SEARCH_QUERY="${{ github.event.inputs.search_query || 'topic:ai-skill OR topic:skill' }}"
          DAYS_AGO=30
          MIN_STARS=10

          # Calculate date (Linux date command)
          SINCE_DATE=$(date -d "$DAYS_AGO days ago" +%Y-%m-%d 2>/dev/null || date -v-${DAYS_AGO}d +%Y-%m-%d)

          # Build the query
          QUERY="${SEARCH_QUERY} created:>${SINCE_DATE} stars:>${MIN_STARS} sort:stars"
          echo "üîç Searching with query: $QUERY"

          # Validate date format
          if ! [[ "$SINCE_DATE" =~ ^[0-9]{4}-[0-1][0-9]-[0-3][0-9]$ ]]; then
            echo "‚ùå Invalid date format: $SINCE_DATE"
            exit 1
          fi

          echo "‚úÖ Valid date format: $SINCE_DATE"

          # URL encode the query properly
          QUERY_ENCODED=$(echo -n "$QUERY" | jq -sRr @uri)

          # Make API request with better error handling
          RESPONSE=$(curl -w "\n%{http_code}" -s \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/search/repositories?q=${QUERY_ENCODED}&per_page=20")

          # Split response and status code
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

          echo "üì° HTTP Status: $HTTP_CODE"

          # Check HTTP status
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "‚ùå API request failed with status: $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            
            # Check for rate limiting
            if [[ "$HTTP_CODE" == "403" ]]; then
              echo "‚ö†Ô∏è Possible rate limit hit"
            fi
            
            # Return empty array instead of failing
            echo "trending_repos=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Validate JSON
          if ! echo "$RESPONSE_BODY" | jq empty 2>/dev/null; then
            echo "‚ùå Invalid JSON response"
            echo "Response: $RESPONSE_BODY"
            echo "trending_repos=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for API errors
          API_ERROR=$(echo "$RESPONSE_BODY" | jq -r '.message // empty')
          if [[ -n "$API_ERROR" ]]; then
            echo "‚ùå API Error: $API_ERROR"
            echo "trending_repos=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get counts
          TOTAL_COUNT=$(echo "$RESPONSE_BODY" | jq -r '.total_count // 0')
          ITEMS_COUNT=$(echo "$RESPONSE_BODY" | jq -r '.items | length')
          echo "üìä API Results: $TOTAL_COUNT total, $ITEMS_COUNT items returned"

          if [[ "$ITEMS_COUNT" -eq 0 ]]; then
            echo "‚ö†Ô∏è No repositories found matching criteria"
            echo "trending_repos=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Process repositories
          TRENDING_JSON=$(echo "$RESPONSE_BODY" | jq -c '[.items[] | {
            url: .html_url,
            name: .full_name,
            stars: .stargazers_count,
            description: (.description // "No description"),
            language: (.language // "Unknown"),
            updated: .updated_at
          }]')

          TOTAL=$(echo "$TRENDING_JSON" | jq 'length')
          echo "‚úÖ Processed $TOTAL trending repositories"

          # Output the result
          echo "trending_repos=$TRENDING_JSON" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  process-skills-with-opencode:
    needs: [parse-issue, discover-trending]
    if: |
      always() &&
      ((needs.parse-issue.result == 'success' && needs.parse-issue.outputs.should_continue == 'true') ||
      (needs.discover-trending.result == 'success' && needs.discover-trending.outputs.trending_repos != '[]'))
    runs-on: ubuntu-latest
    outputs:
      added_skills: ${{ steps.add.outputs.added_skills }}
      has_changes: ${{ steps.add.outputs.has_changes }}
      pr_branch: ${{ steps.add.outputs.pr_branch }}
      skipped_count: ${{ steps.add.outputs.skipped_count }}
      failed_count: ${{ steps.add.outputs.failed_count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine repository URLs to process
        id: repos
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "issues" ]]; then
            REPOS_JSON='${{ needs.parse-issue.outputs.repo_urls }}'
            echo "Debug - Issue repos JSON: $REPOS_JSON"
          else
            REPOS_JSON='${{ needs.discover-trending.outputs.trending_repos }}'
            echo "Debug - Trending repos JSON: $REPOS_JSON"
          fi

          # Check for empty or null JSON
          if [[ -z "$REPOS_JSON" ]] || [[ "$REPOS_JSON" == "null" ]] || [[ "$REPOS_JSON" == "[]" ]]; then
            echo "No repositories to process"
            echo "repos_to_add=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          if ! echo "$REPOS_JSON" | jq empty >/dev/null 2>&1; then
            echo "Invalid JSON for repositories, skipping"
            echo "repos_to_add=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Handle both formats: array of strings (from issues) or array of objects (from trending)
          # Check if first element is a string or object
          FIRST_ITEM_TYPE=$(echo "$REPOS_JSON" | jq -r '.[0] | type')

          if [[ "$FIRST_ITEM_TYPE" == "string" ]]; then
            # From issues - already just URLs
            echo "$REPOS_JSON" | jq -r '.[]' > /tmp/repos_to_add.txt
          else
            # From trending - extract .url field
            echo "$REPOS_JSON" | jq -r '.[].url' > /tmp/repos_to_add.txt
          fi

          TOTAL=$(wc -l < /tmp/repos_to_add.txt | tr -d ' ')
          echo "Will process $TOTAL repositories"
          echo "repos_to_add=$TOTAL" >> $GITHUB_OUTPUT

      - name: Check existing submodules
        run: |
          if [[ -f .gitmodules ]]; then
            grep '^\s*url' .gitmodules | sed 's/.*= //' | sort > /tmp/existing_submodules.txt
            echo "Existing submodules:"
            cat /tmp/existing_submodules.txt
          else
            touch /tmp/existing_submodules.txt
            echo "No existing submodules"
          fi

      - name: Process each repository with OpenCode
        id: add
        run: |
          set -euo pipefail
          ISSUE_NUMBER="${{ github.event.issue.number || 'auto' }}"
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="auto-add-skills-${TIMESTAMP}"
          CATEGORY_OVERRIDE="${{ needs.parse-issue.outputs.category_override }}"

          if [[ "${{ steps.repos.outputs.repos_to_add }}" == "0" ]]; then
            echo "No repositories to process"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "added_skills=[]" >> $GITHUB_OUTPUT
            echo "skipped_count=0" >> $GITHUB_OUTPUT
            echo "failed_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          git checkout -b "$BRANCH_NAME"
          echo "pr_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

          declare -a ADDED_SKILLS=()
          SKIPPED_COUNT=0
          FAILED_COUNT=0

          # Use OpenCode AI for intelligent categorization
          echo "ü§ñ Using OpenCode AI categorization for all skills"
          echo "Allowed categories: learning, frontend, creative, research, tooling, workflows, platforms, publishing"

          while IFS= read -r REPO_URL; do
            if grep -qF "$REPO_URL" /tmp/existing_submodules.txt 2>/dev/null; then
              echo "‚è≠Ô∏è  Skipping existing submodule: $REPO_URL"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              continue
            fi

            echo "üîç Processing $REPO_URL..."

            if [[ -n "$CATEGORY_OVERRIDE" ]]; then
              DETECTED_CATEGORY="$CATEGORY_OVERRIDE"
              echo "‚úÖ Using category override: $DETECTED_CATEGORY"
            else
              # Fetch repo metadata for smarter fallback categorization
              REPO_PATH=$(echo "$REPO_URL" | sed -E 's#https://github\.com/##')
              META_JSON=$(gh api "repos/${REPO_PATH}" --jq '{name:.name,description:.description,topics:.topics}' 2>/dev/null || true)
              META_TEXT=""
              if [[ -n "$META_JSON" ]]; then
                META_TEXT=$(echo "$META_JSON" | jq -r '.name + " " + (.description // "") + " " + ((.topics // []) | join(" "))' || echo "")
              fi

              # Use OpenCode Zen for intelligent categorization (no API key required)
              OPENCODE_OUTPUT=$(opencode --model zen --repo "$REPO_URL" --prompt "Analyze this repository and categorize as one of: learning, frontend, creative, research, tooling, workflows, platforms, publishing. Return JSON: {\"category\":\"...\",\"confidence\":\"low|medium|high\",\"rationale\":\"...\"}." --format json 2>/dev/null || true)
              
              if [[ -n "$OPENCODE_OUTPUT" ]] && echo "$OPENCODE_OUTPUT" | jq empty >/dev/null 2>&1; then
                DETECTED_CATEGORY=$(echo "$OPENCODE_OUTPUT" | jq -r '.category // "tooling"' || echo "tooling")
                echo "‚úÖ OpenCode Zen categorized as: $DETECTED_CATEGORY"
              else
                echo "‚ö†Ô∏è OpenCode Zen CLI not available, using smart metadata analysis"
                REPO_NAME=$(basename "$REPO_URL")
                NAME_LOWER=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')
                META_LOWER=$(echo "$META_TEXT" | tr '[:upper:]' '[:lower:]')
                HAYSTACK="${NAME_LOWER} ${META_LOWER}"

                if [[ "$HAYSTACK" =~ (course|concepts|tutorial|guide|learn|handbook|cheatsheet|curriculum) ]]; then
                  DETECTED_CATEGORY="learning"
                elif [[ "$HAYSTACK" =~ (frontend|ui|ux|component|react|vue|angular|css|design\ system) ]]; then
                  DETECTED_CATEGORY="frontend"
                elif [[ "$HAYSTACK" =~ (prompt|image|art|creative|design\ generator|aesthetic) ]]; then
                  DETECTED_CATEGORY="creative"
                elif [[ "$HAYSTACK" =~ (research|analysis|reverse\ engineering|notebook|security|forensics|ml|ai\ research) ]]; then
                  DETECTED_CATEGORY="research"
                elif [[ "$HAYSTACK" =~ (workflow|planning|tdd|process|methodology|playbook) ]]; then
                  DETECTED_CATEGORY="workflows"
                elif [[ "$HAYSTACK" =~ (marketplace|registry|catalog|directory|hub|platform) ]]; then
                  DETECTED_CATEGORY="platforms"
                elif [[ "$HAYSTACK" =~ (publish|article|blog|newsletter|social|posting) ]]; then
                  DETECTED_CATEGORY="publishing"
                else
                  DETECTED_CATEGORY="tooling"
                fi
              fi
            fi

            REPO_NAME=$(basename "$REPO_URL")
            SKILL_PATH="skills/${DETECTED_CATEGORY}/${REPO_NAME}"

            echo "‚ûï Adding: $REPO_URL -> $SKILL_PATH (ai-categorized)"

            if git submodule add "$REPO_URL" "$SKILL_PATH" 2>&1; then
              ADDED_SKILLS+=("$REPO_URL ($DETECTED_CATEGORY)")
              echo "‚úÖ Added: $REPO_URL"
            else
              echo "‚ùå Failed to add: $REPO_URL"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          done < /tmp/repos_to_add.txt

          echo "skipped_count=$SKIPPED_COUNT" >> $GITHUB_OUTPUT
          echo "failed_count=$FAILED_COUNT" >> $GITHUB_OUTPUT

          if [[ ${#ADDED_SKILLS[@]} -eq 0 ]]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "added_skills=[]" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No new skills to add"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT

            ADDED_JSON=$(printf '%s\n' "${ADDED_SKILLS[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "added_skills=$ADDED_JSON" >> $GITHUB_OUTPUT

            git commit -m "chore: auto-add ${#ADDED_SKILLS[@]} skill(s) using OpenCode AI

          Added skills using OpenCode AI intelligent categorization:
          $(printf '%s\n' "${ADDED_SKILLS[@]}")

          Auto-generated by GitHub Actions"

            git push origin "$BRANCH_NAME"
            echo "‚úÖ Committed and pushed changes"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update issue with status
        if: github.event_name == 'issues' && needs.parse-issue.outputs.permission_ok == 'true' && steps.add.outputs.has_changes == 'true'
        run: |
          ADDED_COUNT=$(echo '${{ steps.add.outputs.added_skills }}' | jq 'length')
          BRANCH="${{ steps.add.outputs.pr_branch }}"

          gh issue comment "${{ github.event.issue.number }}" \
            --body "## üöÄ Skills Addition In Progress

          ‚úÖ Successfully added **$ADDED_COUNT** skill(s) as git submodules using OpenCode categorization

          ### Branch: \`$BRANCH\`

          A pull request will be created shortly for review.

          ---
          ü§ñ Processing by GitHub Actions"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Handle no changes
        if: github.event_name == 'issues' && needs.parse-issue.outputs.permission_ok == 'true' && steps.add.outputs.has_changes == 'false'
        run: |
          if [[ "${{ github.event_name }}" == "issues" ]]; then
            gh issue comment "${{ github.event.issue.number }}" \
              --body "## ‚ÑπÔ∏è No Changes Needed

          All requested repositories are already added as submodules.

          ---
          ü§ñ Processed by GitHub Actions"

            gh issue edit "${{ github.event.issue.number }}" \
              --remove-label "automation-processing" \
              --add-label "automation-complete"
            gh issue close "${{ github.event.issue.number }}"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-pr:
    needs: process-skills-with-opencode
    if: always() && needs.process-skills-with-opencode.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Fetch the branch
        run: |
          git fetch origin ${{ needs.process-skills-with-opencode.outputs.pr_branch }}
          git checkout ${{ needs.process-skills-with-opencode.outputs.pr_branch }}

      - name: Create Pull Request with GitHub CLI
        run: |
          ADDED_COUNT=$(echo '${{ needs.process-skills-with-opencode.outputs.added_skills }}' | jq -r 'length')
          BRANCH="${{ needs.process-skills-with-opencode.outputs.pr_branch }}"

          # Format the skills list
          SKILLS_LIST=$(echo '${{ needs.process-skills-with-opencode.outputs.added_skills }}' | jq -r '.[] | "- " + .')

          TRIGGER_TYPE="${{ github.event_name == 'issues' && 'Issue Request' || 'Scheduled Discovery' }}"
          CURRENT_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Create PR
          gh pr create \
            --base main \
            --head "${BRANCH}" \
            --title "ü§ñ Auto-Add Skills with OpenCode: ${ADDED_COUNT} new skill(s)" \
            --body "## ü§ñ Automated Skills Addition with OpenCode

          This pull request was automatically created to add new skills as git submodules using **OpenCode AI categorization**.

          ### üì¶ Added Skills (Intelligently Categorized)

          ${SKILLS_LIST}

          ### üß† OpenCode Integration

          - **Intelligent Categorization**: Each skill was analyzed using OpenCode AI
          - **Multi-factor Analysis**: README content, repository metadata, and purpose
          - **Smart Fallback**: Basic pattern matching if OpenCode unavailable
          - **Categories**: learning, frontend, creative, research, tooling, workflows, platforms, publishing

          ### ‚úÖ Review Checklist

          - [ ] Verify each skill repository is relevant and useful
          - [ ] Check that OpenCode categorization is accurate
          - [ ] Ensure no duplicates or conflicting skills
          - [ ] Review skill quality and maintenance status

          ### üìä Trigger Information

          - **Trigger Type**: ${TRIGGER_TYPE}
          - **Branch**: ${BRANCH}
          - **Created**: ${CURRENT_DATE}

          ---
          ü§ñ Generated by [Skills Discovery with OpenCode Zen](.github/workflows/skills-discovery.yml) workflow" \
            --label "automated,skills-addition,opencode-integration"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update issue with PR link
        if: github.event_name == 'issues' && needs.parse-issue.outputs.permission_ok == 'true'
        run: |
          PR_NUMBER=$(gh pr list \
            --head "${{ needs.process-skills-with-opencode.outputs.pr_branch }}" \
            --base main \
            --json number \
            --jq '.[0].number')

          if [[ -n "$PR_NUMBER" ]]; then
            gh issue comment "${{ github.event.issue.number }}" \
              --body "## ‚úÖ Pull Request Created

          üìÑ **PR #${PR_NUMBER}** has been created for review!

          ### Next Steps
          - Review pull request to verify OpenCode categorizations
          - Merge if everything looks good, or request changes if needed

          ---
          üîó [View Pull Request](https://github.com/${{ github.repository }}/pull/${PR_NUMBER})
          ü§ñ Automated with OpenCode AI analysis"

            gh issue edit "${{ github.event.issue.number }}" \
              --remove-label "automation-processing" \
              --add-label "automation-complete,pr-created"
            gh issue close "${{ github.event.issue.number }}"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  handle-failure:
    needs: [parse-issue, process-skills-with-opencode, create-pr]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Notify failure
        if: github.event_name == 'issues' && needs.parse-issue.outputs.permission_ok == 'true'
        run: |
          gh issue comment "${{ github.event.issue.number }}" \
            --body "## ‚ùå Automation Failed

          There was an error while processing this request with OpenCode. Please check the [workflow logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.

          ---
          ü§ñ GitHub Actions with OpenCode encountered an error"

          gh issue edit "${{ github.event.issue.number }}" \
            --remove-label "automation-processing" \
            --add-label "automation-failed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
